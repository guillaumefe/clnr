<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Clnr – Text Replacer</title>
    <link rel="icon" href="/favicon.ico">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3e5c4e">
    <link rel="apple-touch-icon" href="icon-192.png">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      html,body {background:#f4f5f6; margin:0; min-height:100vh; font-family:sans-serif;}
      body {position:relative;}
      .container {display:flex; flex-wrap:wrap; gap:2rem; padding:2rem; justify-content:center;}
      .box {background:#fff; border-radius:1.1rem; box-shadow:0 3px 16px #0001; padding:1.25rem; min-width:260px; flex:1 1 320px; max-width:500px; display:flex; flex-direction:column; gap:1rem;}
      .label {font-weight:bold; margin-bottom:.35em; color:#262e36;}
      .editable,.result {min-height:108px; border:1px solid #ddd; border-radius:0.6em; padding:.7em .9em; background:#fcfcfc; outline:none; font-size:1.06rem; overflow-y:auto; color:#222; transition: border .18s;}
      .editable:focus {border-color: #5f9e7b;}
      .result {
      background: #f7faf8;
      word-break: break-word;
      font: inherit; 
      white-space: inherit;
      }
      table {width:100%; border-collapse:separate; border-spacing:0 4px;}
      td {padding:2px 4px;}
      input[type="text"] {width:100%; padding:5px; border-radius:0.4em; border:1px solid #ccc; font-size:1em; background:#f9f9f9;}
      .replace-row input { min-width:70px; }
      .replace-row td:last-child {
      display: flex;
      align-items: center;
      }
      .replace-row .move-btn {
      margin: 0 .3em;
      }
      .replace-row button[title="Remove"] {
      margin-left: auto;
      }
      .btn {background:#3e5c4e; color:white; border:none; border-radius:0.5em; padding:.65em 1.1em; font-size:1em; cursor:pointer; margin-top:1em; align-self:flex-end; transition:background .14s;}
      .btn:active {background:#304b3e;}
      .add-row {background:#e5e6e7; color:#2d3436; padding:.32em 1em; border-radius:.5em; font-size:.97em; margin-top:.4em; cursor:pointer; border:none; transition:background .15s;}
      .add-row:hover {background:#5f9e7b;color:#fff;}
      .tool-row {display:flex; flex-wrap:wrap; gap:.7em;}
      .tool-row button {padding:0.47em 1em; font-size:.97em; border-radius:.5em;}
      #toast {position:fixed; left:50%; bottom:2.2rem; transform:translateX(-50%); background:#262e36; color:#fff; padding:.78em 1.4em; border-radius:1em; font-size:1.05em; box-shadow:0 2px 12px #0003; z-index:2222; opacity:0; pointer-events:none; transition:opacity .26s, bottom .26s; display:flex; gap:.7em; align-items:center;}
      #toast.visible { opacity:1; bottom:3.1rem; pointer-events:auto;}
      .modal {position:fixed; left:0;top:0;right:0;bottom:0;z-index:3000; background:rgba(36,45,56,0.08); display:flex;align-items:center;justify-content:center;}
      .modal-box {background:#fff; border-radius:.95em; box-shadow:0 2px 12px #0002; padding:1.3em 1.1em; text-align:center; min-width:210px; max-width:92vw; display:flex;flex-direction:column;gap:1.1em;}
      .modal-box input[type=password] {font-size:1.07em; border-radius:.4em; padding:.65em; border:1px solid #bbb;}
      .modal-box button {font-size:1em; border-radius:.4em; padding:.6em 1.05em;}
      #pw-modal.splash {background:linear-gradient(125deg,#f6f7fa 0%,#e7ebef 100%); min-height:100vh;}
      .splash-box {max-width:340px; min-width:0; width:92vw; box-shadow:0 2px 18px #2221; background:#fff; border-radius:1.4em; padding:2em 1.2em 1.2em 1.2em; display:flex;flex-direction:column;gap:1.2em;align-items:center;margin:0 auto; animation: fadeInSplash .7s;}
      .splash-box form {width: 100%; box-sizing: border-box;}
      @keyframes fadeInSplash {from{transform:scale(.98) translateY(32px); opacity:0;}to{opacity:1;}}
      .clnr-logo {font-size:2.05em; font-weight:700; letter-spacing:-0.04em; color:#304b3e; text-shadow: 0 1px 0 #e9ecef; font-family: "Segoe UI", "Inter", Arial, sans-serif; margin-bottom:0.12em;}
      .slogan {color:#3e5c4e;font-size:1.11em;margin-top:.07em;margin-bottom:.3em; font-weight:500; font-family: "Segoe UI", "Inter", Arial, sans-serif;}
      .desc {color:#222;font-size:1.01em; margin-bottom:0.7em;line-height:1.6; font-family: "Segoe UI", "Inter", Arial, sans-serif;}
      .pw-input {width: 100%; box-sizing: border-box; padding: .8em .9em; font-size: 1.07em; border-radius: 0.5em; border: 1px solid #bbb; margin-bottom: .5em; background: #fff; outline: none; transition: border 0.18s, box-shadow 0.18s; display: block;}
      .pw-input:focus {border-color: #3e5c4e; box-shadow: 0 0 0 2px #d7ebe3;}
      .reset-btn {margin-top:.7em; background:#ddd; color:#7c2222;border:none;padding:.44em 1.1em;border-radius:0.6em; font-size:.97em; cursor:pointer;transition:background .13s;}
      .reset-btn:hover {background:#cfd5dc;}
      .small-txt {color:#888;font-size:.97em;}
      .hash-indicator {display:inline-block; margin-left:.7em; font-size:.87em; color:#b2baaf; vertical-align:middle;}
      .swap-btn {background:#eceff1; color:#3e5c4e; border-radius:.7em; border:none; font-size:1.12em; padding:.45em .85em; margin-left:.7em; cursor:pointer;}
      .swap-btn:active {background:#d7ebe3;}
      .move-btn {background:#eceff1; color:#3e5c4e; border:none; border-radius:.4em; padding:0.2em 0.6em; font-size:1em; margin:0 2px; cursor:pointer;}
      .move-btn:active {background:#d7ebe3;}
      .loader {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(255,255,255,0.6);
      display: flex; align-items: center; justify-content: center;
      z-index: 9999;
      transition: opacity .3s;
      }
      .loader.hidden { opacity: 0; pointer-events: none; }
      .loader-inner {
      background: #fff;
      padding: 1em 1.5em;
      border-radius: .6em;
      box-shadow: 0 2px 12px rgba(0,0,0,.15);
      display: flex; align-items: center; gap: .8em;
      }
      .progress-bar {
      width: 200px; height: 8px;
      background: #eee;
      border-radius: 4px;
      overflow: hidden;
      }
      .progress-bar::after {
      content: "";
      display: block;
      width: 0; height: 100%;
      background: #3e5c4e;
      transition: width .2s;
      }
      .progress-text {
      font-size: .95em;
      color: #304b3e;
      width: 3em;
      text-align: right;
      }
      .sr-only {
        position: absolute !important;
        height: 1px; width: 1px;
        overflow: hidden;
        clip: rect(1px,1px,1px,1px);
        white-space: nowrap;
      }

      @media (max-width: 900px) {
      .container {flex-direction:column; padding:1.2rem;}
      .box{max-width:100%; min-width:0;}
      .splash-box {max-width:99vw;}
      }
      @media (max-width: 540px) {
      .container {padding:.55em;}
      .splash-box {padding:1.2em .3em .7em .3em;}
      .box {padding:.8em;}
      .editable, .result {font-size:.98em;}
      }
    </style>
  </head>
  <body>
    <h1 style="display:none">Clnr – Text Replacer</h1>
    <div id="pw-modal" class="modal splash" style="display:flex;" role="dialog" aria-modal="true" aria-labelledby="pw-modal-title">
      <div class="splash-box">
        <h2 id="pw-modal-title" class="clnr-logo">🧽</h2>
        <div class="clnr-logo">Clnr</div>
        <div class="slogan">Find & replace, made simple</div>
        <div class="desc">Find & replace multiple words and phrases instantly, safely on your device.<br>Your data stays private and encrypted.</div>
        <form onsubmit="submitPassword(); return false;">
          <input type="text" name="username" autocomplete="username" style="display:none" tabindex="-1">
          <input id="pw-input" type="password" placeholder="Enter your password..." autocomplete="current-password" class="pw-input">
          <button type="submit" style="background:#3e5c4e;color:#fff;border:none;width:100%;padding:.7em 0;font-size:1.08em;border-radius:.6em;">Access Clnr</button>
        </form>
        <div id="pw-err" style="color:#e74c3c;font-size:.98em;min-height:1.3em;"></div>
        <button type="button" class="reset-btn" onclick="confirmReset()">Reset app (forgot password?)</button>
        <div class="small-txt">This erases all local data. No recovery possible.</div>
      </div>
    </div>
    <div id="modal-overlay" class="modal" style="display:none;" role="dialog" aria-modal="true" aria-labelledby="modal-title">
      <div class="modal-box">
        <h2 id="modal-title" style="font-size:1.11em; font-weight:bold;"></h2>
        <div id="modal-title-text" style="font-size:1.11em; font-weight:bold;"></div>
        <form id="modal-form" onsubmit="handleModalOk(event); return false;">
          <input type="text" name="username" autocomplete="username" style="display:none" tabindex="-1">
          <input id="modal-pw" type="password" placeholder="Password..." autocomplete="current-password" autofocus>
          <button id="modal-ok" style="background:#3e5c4e;color:#fff;border:none;">OK</button>
          <button onclick="closeModal()" style="background:#e5e6e7;color:#333;border:none;">Cancel</button>
          <div id="modal-err" style="color:#e74c3c;font-size:.97em;min-height:1.2em"></div>
        </form>
      </div>
    </div>
    <div class="container" id="main-ui" style="display:none;">
      <div class="box">
        <div class="label">Your text:
          <span class="hash-indicator" id="hash-edit"></span>
        </div>
        <div style="display:flex;gap:.6em;align-items:center;flex-wrap:wrap; margin-bottom:.3em;">
          <button class="swap-btn" onclick="swapText()" title="Swap both sides" aria-label="Swap both sides">⇄</button>
          <span style="font-size:.99em;">Replacement direction:</span>
          <label style="display:flex;align-items:center;gap:.32em;font-size:.96em;cursor:pointer;">
          <input type="checkbox" id="horizDir" style="margin:0; checked">
          <span id="horizText"><span id="horizArrow" style="font-size:1.13em;">→
          </label>
          <label style="display:flex;align-items:center;gap:.32em;font-size:.96em;cursor:pointer;">
          <input type="checkbox" id="vertDir" style="margin:0;">
          <span id="vertArrow">↓</span>
          </label>
        </div>
        <label for="editable">Text to process (editable field)</label>
        <div
          id="editable"
          class="editable"
          contenteditable="true"
          spellcheck="true"
          role="textbox"
          aria-multiline="true"
          aria-label="Text to process"
          aria-describedby="editable-desc"
          tabindex="0">
        </div>
        <div id="editable-desc" class="sr-only">
          Enter or paste the text you want to process. This field is editable.
        </div>
        <table>
          <thead>
            <tr>
              <th scope="col">Find</th>
              <th scope="col"></th>
              <th scope="col">Replace with</th>
              <th scope="col">Actions</th>
            </tr>
          </thead>
          <tbody id="replace-tbody"></tbody>
        </table>
        <button type="button" class="add-row" onclick="addRow()">+ Add replacement</button>
        <div class="tool-row" style="margin-top:.8em;">
          <button class="btn" onclick="doReplace()">Replace</button>
          <button class="btn" style="background:#777;" onclick="copyResult()">Copy result</button>
          <button class="btn" style="background:#d9534f; margin-left:.5em;" onclick="clearResult()">Clear result</button>
          <button class="btn" style="background:#e5e6e7; color:#2d3436;" onclick="openExportModal()">Export list</button>
          <button class="btn" style="background:#e5e6e7; color:#2d3436;" onclick="openImportModal()">Import list</button>
        </div>
      </div>
      <div class="box">
        <div class="label">Result:
          <span class="hash-indicator" id="hash-result"></span>
        </div>
        <pre id="result" class="result" contenteditable="false"></pre>
      </div>
      <div id="clnr-loader" class="loader hidden">
        <div class="loader-inner">
          <div id="clnr-progress-bar" class="progress-bar"></div>
          <div id="clnr-progress-text" class="progress-text">0 %</div>
        </div>
      </div>
    </div>
    <div id="toast" role="status" aria-live="polite"></div>
    <input type="file" id="importFile" accept=".encjson,application/octet-stream" style="display:none" onchange="onImportFile(event)">
    <script>
      const DB_NAME = "enc-clnr";
      const DB_STORE = "main";
      let db = null;
      let horizontalDir = true;
      let verticalDir = true;
      let currentReplacements = [];
      let lastUniqueMark = '';
      let masterKey = null;
      const SALT = new TextEncoder().encode("clnr"); 
      function hashShort(str) {
        return crypto.subtle.digest('SHA-256', new TextEncoder().encode(str)).then(b =>
          Array.from(new Uint8Array(b)).slice(0,3).map(x => x.toString(16).padStart(2,'0')).join('')
        );
      }
      
      function matchCase(text, pattern) {
        if (pattern.toUpperCase() === pattern) {
          return text.toUpperCase();
        }
        if (pattern.toLowerCase() === pattern) {
          return text.toLowerCase();
        }
        if (pattern[0].toUpperCase() === pattern[0]) {
          return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();
        }
        return text;
      }
      
      function updateHashes() {
        hashShort(document.getElementById('editable').innerText).then(h => {
          let e = document.getElementById('hash-edit');
          e.textContent = h;
          e.className = 'hash-indicator';
        });
        let res = document.getElementById('result').innerText.trim();
        let e = document.getElementById('hash-result');
        if (res.length > 0) {
          hashShort(res).then(h => {
            e.textContent = h;
            e.className = 'hash-indicator';
          });
        } else {
          e.textContent = "";
        }
      }
      
      async function digest(str) {
        return await window.crypto.subtle.digest('SHA-256', new TextEncoder().encode(str));
      }
      
      function toHex(arrayBuffer) {
        return [...new Uint8Array(arrayBuffer)].map(x => x.toString(16).padStart(2,'0')).join('');
      }
      
      function fromHex(str) {
        return Uint8Array.from(str.match(/.{2}/g).map(b => parseInt(b,16)));
      }
      
      async function getKey(password) {
        const keyMaterial = await window.crypto.subtle.importKey(
          "raw",
          new TextEncoder().encode(password),
          "PBKDF2",
          false,
          ["deriveBits", "deriveKey"]
        );
        return await window.crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt: SALT, 
            iterations: 100_000, 
            hash: "SHA-256"
          },
          keyMaterial,
          { name: "AES-GCM", length: 256 },
          false,
          ["encrypt", "decrypt"]
        );
      }
      
      async function encryptData(obj, key) {
        let iv = window.crypto.getRandomValues(new Uint8Array(12));
        let data = new TextEncoder().encode(JSON.stringify(obj));
        let ct = await window.crypto.subtle.encrypt({name:"AES-GCM", iv}, key, data);
        let ivhex = toHex(iv);
        let cthex = toHex(ct);
        return ivhex + ':' + cthex;
      }
      
      async function decryptData(enc, key) {
        try {
          let [ivhex, cthex] = enc.split(':');
          let iv = fromHex(ivhex);
          let ct = fromHex(cthex);
          let plain = await window.crypto.subtle.decrypt({name:"AES-GCM", iv}, key, ct);
          return JSON.parse(new TextDecoder().decode(plain));
        } catch (e) {
          return null;
        }
      }
      
      function openDB() {
        return new Promise((res, rej) => {
          let r = indexedDB.open(DB_NAME, 1);
          r.onerror = () => rej(r.error);
          r.onupgradeneeded = () => { r.result.createObjectStore(DB_STORE); }
          r.onsuccess = () => { db = r.result; res(); }
        });
      }
      
      function saveToDB(obj) {
        return new Promise(async (res, rej) => {
          let enc = await encryptData(obj, masterKey); // ici masterKey est la clé dérivée, pas le mdp
          let tx = db.transaction(DB_STORE, "readwrite");
          let store = tx.objectStore(DB_STORE);
          store.put(enc, "data");
          tx.oncomplete = () => res();
          tx.onerror = () => rej(tx.error);
        });
      }
      
      function loadFromDB() {
        return new Promise((res, rej) => {
          let tx = db.transaction(DB_STORE, "readonly");
          let store = tx.objectStore(DB_STORE);
          let getReq = store.get("data");
          getReq.onsuccess = () => res(getReq.result);
          getReq.onerror = () => rej(getReq.error);
        });
      }
      
      function showToast(msg, success = true) {
        let toast = document.getElementById('toast');
        toast.innerHTML = (success
          ? `<svg width="22" height="22" style="vertical-align:middle"><circle cx="11" cy="11" r="11" fill="#5f9e7b"/><path d="M7 11l3 3 5-5" stroke="#fff" stroke-width="2" fill="none" stroke-linecap="round"/></svg>`
          : `<svg width="22" height="22"><circle cx="11" cy="11" r="11" fill="#e74c3c"/><path d="M7 7l8 8M15 7l-8 8" stroke="#fff" stroke-width="2" stroke-linecap="round"/></svg>`
        ) + `<span style="margin-left:.8em">${msg}</span>`;
        toast.className = 'visible';
        setTimeout(() => { toast.className = ''; }, 1800);
      }
      
      function getReplacements() {
        const replaces = [];
        document.querySelectorAll('#replace-tbody tr').forEach(row => {
          const a = row.children[0].querySelector('input').value;
          const b = row.children[2].querySelector('input').value;
          const from = horizontalDir ? a : b;
          const to   = horizontalDir ? b : a;
          replaces.push({ from, to });
        });
        return verticalDir ? replaces.slice() : replaces.slice().reverse();
      }
      
      function renderReplaceTable(replaces) {
        const tbody = document.getElementById('replace-tbody');
        tbody.innerHTML = '';
        (replaces || []).forEach(x => addRow(x.from, x.to, false));
        if (!replaces || replaces.length === 0) addRow('', '', false);
      }
      
      function setReplacements(replaces) {
        currentReplacements = (replaces || []).slice();
        renderReplaceTable(currentReplacements);
        updateHashes();
      }
      
      function reorderRows() {
        const list = currentReplacements.slice().reverse();
        renderReplaceTable(list);
      }
      
      function generateUUID() {
        return crypto.randomUUID();
      }
      
      function addRow(valFrom = '', valTo = '', focus = true) {
        const tbody = document.getElementById('replace-tbody');
        const tr = document.createElement('tr');
        tr.className = "replace-row";
        tr.dataset.fromTouched = valFrom !== '';
        tr.dataset.toTouched   = 'false';

        const uuid = generateUUID();
        tr.innerHTML = `
          <td>
            <label for="from-${uuid}" class="sr-only">Find text to replace</label>
            <input type="text" placeholder="Find" value="${valFrom}" aria-label="Find text to replace">
          </td>
          <td style="width:26px; text-align:center;" class="arrow-cell"></td>
          <td>
            <label for="to-${uuid}" class="sr-only">Replacement text</label>
            <input type="text" placeholder="Replace with" value="${valTo}" aria-label="Replacement text">
          </td>
          <td style="white-space: nowrap;">
            <button type="button" class="move-btn" title="Move up" onclick="moveRowUp(this)">↑</button>
            <button type="button" class="move-btn" title="Move down" onclick="moveRowDown(this)">↓</button>
            <button type="button" class="move-btn" title="Remove" onclick="removeRow(this)">✕</button>
          </td>
        `;
      
        tbody.appendChild(tr);
      
        const fromInput = tr.children[0].querySelector('input');
        const toInput   = tr.children[2].querySelector('input');
      
        // 1) If user hasn't touched "Replace with", auto-generate a placeholder
        fromInput.addEventListener('input', e => {
          if (tr.dataset.toTouched === 'false') {
            const len = e.target.value.length;
            toInput.value = generateUUID(len);
            updateCurrentReplacementsFromTable();
            saveUI();
            updateHashes();
          }
        });
      
        // 2) Lock once user types in "Replace with"
        toInput.addEventListener('input', () => {
            if (toInput.value === '') {
              // if emptied, resume auto-generation
              tr.dataset.toTouched = 'false';
            } else {
              // once non-empty, stop overwriting
              tr.dataset.toTouched = 'true';
            }
            checkDuplicateReplacements();
        });
      
        renderArrows();
        updateHashes();
        saveUI();
        if (focus) setTimeout(() => fromInput.focus(), 50);
      }
      
      function updateCurrentReplacementsFromTable() {
        const rows = document.querySelectorAll('#replace-tbody tr');
        currentReplacements = [];
        rows.forEach(row => {
          let from = row.children[0].querySelector('input').value;
          let to   = row.children[2].querySelector('input').value;
          currentReplacements.push({ from, to });
        });
        checkDuplicateReplacements();
      }
      
      function moveRowUp(btn) {
        let tr = btn.closest('tr');
        let prev = tr.previousElementSibling;
        if (prev) tr.parentNode.insertBefore(tr, prev);
        updateCurrentReplacementsFromTable();
        saveUI();
        renderArrows();
        updateHashes();
      }
      
      function moveRowDown(btn) {
        let tr = btn.closest('tr');
        let next = tr.nextElementSibling;
        if (next) tr.parentNode.insertBefore(next, tr);
        updateCurrentReplacementsFromTable();
        saveUI();
        renderArrows();
        updateHashes();
      }
      
      function removeRow(btn) {
        btn.closest('tr').remove();
        updateCurrentReplacementsFromTable();
        saveUI();
        renderArrows();
        updateHashes();
      }
      
      function updateDirLabels() {
        document.getElementById('horizArrow').textContent = horizontalDir ? '→' : '←';
        document.getElementById('vertArrow').textContent = verticalDir ? '↓' : '↑';
      }
      
      function renderArrows() {
        let rows = document.querySelectorAll('#replace-tbody tr');
        rows.forEach(row => {
          let arrow = row.querySelector('.arrow-cell');
          arrow.textContent = horizontalDir ? '→' : '←';
        });
        updateDirLabels();
      }

      function confirmReset() {
        if (!confirm("This will erase all local data and cannot be undone.\nAre you sure you want to reset the app?")) return;
        openDB().then(() => {
          let tx = db.transaction(DB_STORE, "readwrite");
          let store = tx.objectStore(DB_STORE);
          store.delete("data");
          tx.oncomplete = () => {
            showToast("App reset! Please reload or enter a new password.", true);
            setTimeout(() => window.location.reload(), 900);
          };
          tx.onerror = () => showToast("Reset failed.", false);
        });
      }

      document.getElementById('horizDir').onchange = function() {
        horizontalDir = this.checked;
        renderArrows();
      };
      document.getElementById('vertDir').onchange = function() {
        verticalDir = this.checked;
        reorderRows();
        updateDirLabels();
      };
      
      function showLoader() {
        document.getElementById('clnr-loader').classList.remove('hidden');
      }
      
      function updateLoader(pct) {
        document.getElementById('clnr-progress-text').textContent = pct + ' %';
        document.getElementById('clnr-progress-bar').style.setProperty('--progress', pct + '%');
      }
      
      function hideLoader() {
        document.getElementById('clnr-loader').classList.add('hidden');
      }
      
      function getStructuredText(el) {
        let txt = '';
        el.childNodes.forEach(node => {
          if (node.nodeType === Node.TEXT_NODE) {
            txt += node.data;
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName.toLowerCase();
            if (tag === 'br') {
              txt += '\n';
            } else if (
              ['p','div','section','article','li','ul','ol',
               'h1','h2','h3','h4','h5','h6','blockquote']
              .includes(tag)
            ) {
              // take the block text + a line break
              txt += getStructuredText(node).replace(/\n+$/,'') + '\n';
            } else {
              // inline or other → recurse
              txt += getStructuredText(node);
            }
          }
        });
        return txt;
      }
      
      
      
      async function doReplace() {
      const inputDiv  = document.getElementById('editable');
      const outputDiv = document.getElementById('result');
      
      // 1) Get and filter replacements
      let reps = getReplacements().filter(r => r.from.trim().length > 0);
      if (!reps.length) return;
      if (!verticalDir) reps.reverse();
      
      showLoader();
      const total = reps.length;
      
      // Start from a blank clone
      let clone = inputDiv.cloneNode(true);
      
      for (let pass = 0; pass < total; pass++) {
      const { from, to } = reps[pass];
      
      // 2) Collect all TEXT_NODEs to reconstruct the plain text
      const walker1 = document.createTreeWalker(clone, NodeFilter.SHOW_TEXT, null, false);
      const boundaries = []; // { node, start, end }
      let idx = 0, node;
      while (node = walker1.nextNode()) {
        boundaries.push({ node, start: idx, end: idx + node.nodeValue.length });
        idx += node.nodeValue.length;
      }
      const fullText = boundaries.map(b => b.node.nodeValue).join('');
      
      // 3) Find all occurrences of `from`
      const re = new RegExp(escapeRegExp(from), 'gi');
      const matches = [];
      let m;
      while (m = re.exec(fullText)) {
        matches.push({ index: m.index, length: m[0].length, text: m[0] });
      }
      
      // 4) Replace **backwards** so that the following ones are not shifted
      for (let i = matches.length - 1; i >= 0; i--) {
        const { index, length, text: matchedText } = matches[i];
      
        // Find the start and end node
        const startB = boundaries.find(b => b.start <= index  && b.end >  index);
        const endB   = boundaries.find(b => b.start <  index+length && b.end >= index+length);
      
        const range = document.createRange();
        const startOffset = index  - startB.start;
        const endOffset   = index+length - endB.start;
        range.setStart(startB.node, startOffset);
        range.setEnd(endB.node,   endOffset);
      
        // Calculate the replacement with matchCase
        const rawTo = to;
        const repl  = matchCase(rawTo, matchedText);
      
        // Apply
        range.deleteContents();
        range.insertNode(document.createTextNode(repl));
      }
      
      // 5) Update loader
      updateLoader(Math.round(((pass+1)/total)*100));
      // Wait a tick for the UI
      await new Promise(requestAnimationFrame);
      }
      
      // 6) Inject the final result
      outputDiv.innerHTML = '';
      Array.from(clone.childNodes).forEach(n => outputDiv.appendChild(n));
      
      hideLoader();
      updateHashes();
      
      // 7) Verification
      verifyReplacements(reps, outputDiv);
      }
      
      
      
      
      
      function getAllText(container) {
      return Array.from(container.childNodes)
      .map(node => node.nodeType === Node.TEXT_NODE
        ? node.data
        : getStructuredText(node)
      )
      .join('');
      }
      
      
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      }
      
      async function copyResult() {
        let resultDiv = document.getElementById('result');
        let html = resultDiv.innerHTML;
        let ok = false;
        if (navigator.clipboard && window.ClipboardItem) {
          try {
            let blob = new Blob([html], {type: "text/html"});
            await navigator.clipboard.write([new ClipboardItem({
              "text/html": blob,
              "text/plain": new Blob([resultDiv.innerText], {type:"text/plain"})
            })]);
            showToast("Copied!", true);
            ok = true;
          } catch (e) {}
        }
        if (!ok) {
          let sel = window.getSelection();
          let range = document.createRange();
          range.selectNodeContents(resultDiv);
          sel.removeAllRanges(); sel.addRange(range);
          try { ok = document.execCommand('copy'); } catch (e) { ok = false; }
          sel.removeAllRanges();
          showToast(ok ? "Copied!" : "Copy failed", ok);
        }
      }
      
      function clearResult() {
        const outputDiv = document.getElementById('result');
        outputDiv.innerHTML = '';        // clears the result area
        updateHashes();                  // update hash (optional)
        showToast("Result cleared!", true);  // user message
      }
      
      function swapText() {
        let left  = editable.innerHTML;
        let right = result.innerHTML;
        editable.innerHTML = right;
        result.innerHTML   = left;
      
        horizontalDir = true;
        verticalDir   = true;
        document.getElementById('horizDir').checked = true;
        document.getElementById('vertDir').checked  = true;
      
        renderArrows();
        updateHashes();
        saveUI();
      }
       
      function saveUI() {
        if (!masterKey) return;
        let obj = {
          text: document.getElementById('editable').innerHTML,
          replacements: getReplacements(),
          uniqueMark: lastUniqueMark
        };
        saveToDB(obj);
      }
      
      async function restoreUI(obj) {
        document.getElementById('editable').innerHTML = obj.text || '';
        setReplacements(obj.replacements || []);
        lastUniqueMark = obj.uniqueMark || '';
        document.getElementById('result').innerHTML = '';
        updateHashes();
      }
      
      function openExportModal() {
        document.getElementById('modal-title').textContent = "Export replacements";
        document.getElementById('modal-err').textContent = '';
        document.getElementById('modal-pw').value = '';
      
        if (!document.getElementById('modal-filename')) {
          const input = document.createElement('input');
          input.type = 'text';
          input.id = 'modal-filename';
          input.placeholder = 'File name (without extension)';
          input.className = 'pw-input';
          input.style.marginTop = '.6em';
      
          const form = document.getElementById('modal-form');
          form.insertBefore(input, form.firstChild);
        }
      
        document.getElementById('modal-overlay').style.display = '';
        window.modalOkCallback = async (pw) => {
          const fileNameInput = document.getElementById('modal-filename').value.trim();
          const fileName = fileNameInput !== '' ? fileNameInput : 'replacements';
      
          try {
            let replaces = getReplacements();
            let exportKey = await getKey(pw);
            let enc = await encryptData({
              replacements: replaces,
              horizontalDir,
              verticalDir,
              uniqueMark: lastUniqueMark
            }, exportKey);
            let blob = new Blob([enc], { type: "application/octet-stream" });
            let a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = fileName + ".encjson";
            a.click();
            setTimeout(() => URL.revokeObjectURL(a.href), 600);
            showToast("Exported!", true);
          } catch (e) {
            showToast("Export failed!", false);
          }
        };
      
        setTimeout(() => document.getElementById('modal-filename').focus(), 100);
        trapFocus(document.getElementById('modal-overlay'));
      }
      
      function openImportModal() {
        openModal("Enter password to decrypt import:", (pw) => {
          window.__importPw = pw;
          document.getElementById('importFile').click();
        });
      }
      
      function handleModalOk(e) {
        let pw = document.getElementById('modal-pw').value;
        if (!pw) {
          document.getElementById('modal-err').textContent = 'Password is required';
          return;
        }
      
        document.getElementById('modal-overlay').style.display = 'none';
        if (window.modalOkCallback) window.modalOkCallback(pw);
      }

      
      function onImportFile(e) {
        let file = e.target.files[0];
        if (!file) return;
        let reader = new FileReader();
        reader.onload = async function(ev) {
          try {
            let enc = ev.target.result;
            let importKey = await getKey(window.__importPw || '');
            let obj = await decryptData(enc, importKey);
            window.__importPw = undefined;
            if (obj && Array.isArray(obj.replacements)) {
              horizontalDir = 'horizontalDir' in obj ? obj.horizontalDir : true;
              verticalDir   = 'verticalDir'   in obj ? obj.verticalDir   : true;
              lastUniqueMark = obj.uniqueMark || '';
              document.getElementById('horizDir').checked = horizontalDir;
              document.getElementById('vertDir').checked = verticalDir;
              renderArrows();
              setReplacements(obj.replacements.slice());
              saveUI();
              showToast("List imported!", true);
            } else if (Array.isArray(obj)) {
              horizontalDir = false;
              verticalDir = false;
              lastUniqueMark = '';
              document.getElementById('horizDir').checked = horizontalDir;
              document.getElementById('vertDir').checked = verticalDir;
              renderArrows();
              setReplacements(obj.slice());
              saveUI();
              showToast("List imported!", true);
            } else throw "Format error";
          } catch (e) {
            showToast("Import failed!", false);
          }
        }
        reader.readAsText(file);
      }

      function trapFocus(modal) {
        const focusableEls = modal.querySelectorAll('input, button, [tabindex]:not([tabindex="-1"])');
        const first = focusableEls[0], last = focusableEls[focusableEls.length - 1];
        modal.addEventListener('keydown', function(e){
          if (e.key === 'Tab') {
            if (e.shiftKey) { // Shift+Tab
              if (document.activeElement === first) {
                last.focus();
                e.preventDefault();
              }
            } else { // Tab
              if (document.activeElement === last) {
                first.focus();
                e.preventDefault();
              }
            }
          }
          if (e.key === 'Escape') closeModal();
        });
      }
      
      function openModal(title, onOk) {
        document.getElementById('modal-title').textContent = title;
        document.getElementById('modal-err').textContent = '';
        document.getElementById('modal-pw').value = '';
        document.getElementById('modal-overlay').style.display = '';
        window.modalOkCallback = onOk;
        setTimeout(() => document.getElementById('modal-pw').focus(), 100);
        trapFocus(document.getElementById('modal-overlay'));
      }
      
      function closeModal() {
        document.getElementById('modal-overlay').style.display = 'none';
      }
      
      function askPassword() {
        document.getElementById('pw-err').textContent = '';
        document.getElementById('pw-input').value = '';
        document.getElementById('pw-modal').style.display = 'flex';
        setTimeout(() => {
          document.getElementById('pw-input').focus();
          trapFocus(document.getElementById('pw-modal'));
        }, 100);
      }
      
      async function submitPassword(e) {
        if (!db) {
          await openDB();
          if (!db) {
            document.getElementById('pw-err').textContent = 'Database not ready, please reload the page.';
            return;
          }
        }
        let pw = document.getElementById('pw-input').value;
        if (!pw) {
          document.getElementById('pw-err').textContent = 'Password is required';
          return;
        }
        masterKey = await getKey(pw);
        let enc = await loadFromDB();
        if (!enc) {
          await saveToDB({text:'', replacements:[{from:'',to:''}], uniqueMark: ''});
          document.getElementById('pw-modal').style.display='none';
          document.getElementById('main-ui').style.display='';
          restoreUI({text:'', replacements:[{from:'',to:''}], uniqueMark: ''});
        } else {
          let obj = await decryptData(enc, masterKey); 
          if (!obj) {
            document.getElementById('pw-err').textContent = "Wrong password.";
          } else {
            document.getElementById('pw-modal').style.display='none';
            document.getElementById('main-ui').style.display='';
            restoreUI(obj);
          }
        }
        pw = null;
      }

      function checkDuplicateReplacements() {
        const toValues = [];
        let duplicate = false;
      
        document.querySelectorAll('#replace-tbody tr').forEach(row => {
          const toVal = row.children[2].querySelector('input').value.trim();
          if (toVal !== '') {
            if (toValues.includes(toVal)) {
              duplicate = true;
              row.children[2].querySelector('input').style.borderColor = 'red';
            } else {
              toValues.push(toVal);
              row.children[2].querySelector('input').style.borderColor = '';
            }
          }
        });
      
        if (duplicate) {
          showToast("Duplicate replacement values are not allowed!", false);
        }
      
        return !duplicate;
      }
      
      document.addEventListener('click', function(e) {
        const btn = e.target.closest('button');
        if (!btn) return;
        const label = btn.getAttribute('title') || btn.textContent.trim();
        showToast(`✔ ${label}`, true);
      });

      document.getElementById('editable').addEventListener('keydown', function(e){
        if (e.key === 'Escape') {
          e.target.blur();
        }
      });
      
      document.getElementById('horizDir').checked = horizontalDir;
      document.getElementById('vertDir').checked = verticalDir;
      renderArrows();
      updateDirLabels();
      document.addEventListener('input', function(e) {
        if (!masterKey) return;
        if (e.target.closest('.editable') || e.target.closest('#replace-tbody')) {
          updateHashes();
          saveUI();
        }
      });
      (async function() {
        await openDB();
        askPassword();
      })();
      window.addEventListener('beforeunload', saveUI);
      
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('sw.js')
            .then(reg => console.log("Service Worker registered"))
            .catch(err => console.warn("Service Worker registration failed:", err));
        });
      }

      // Store the install prompt event for later use
      let deferredPrompt;
      
      // Listen for the 'beforeinstallprompt' event (triggered when the app meets installability criteria)
      window.addEventListener('beforeinstallprompt', (e) => {
        // Prevent the default mini-infobar from appearing on mobile
        e.preventDefault();
        deferredPrompt = e;
      
        // If the toast already exists, don't create a new one
        if (document.getElementById('install-toast')) return;
      
        // Create the toast container
        const toast = document.createElement('div');
        toast.id = 'install-toast';
        toast.style.position = 'fixed';
        toast.style.left = '50%';
        toast.style.bottom = '2.2em';
        toast.style.transform = 'translateX(-50%)';
        toast.style.background = '#262e36';
        toast.style.color = '#fff';
        toast.style.padding = '1em 1.7em 1em 1.2em';
        toast.style.borderRadius = '1em';
        toast.style.fontSize = '1.09em';
        toast.style.boxShadow = '0 2px 12px #0003';
        toast.style.zIndex = 3000;
        toast.style.display = 'flex';
        toast.style.alignItems = 'center';
        toast.style.gap = '.85em';
      
        // Add an icon to the toast
        toast.innerHTML = `
          <svg width="26" height="26" style="vertical-align:middle">
            <circle cx="13" cy="13" r="13" fill="#5f9e7b"/>
            <path d="M9 15l3 3 5-7" stroke="#fff" stroke-width="2" fill="none" stroke-linecap="round"/>
          </svg>`;
      
        // Add message text to the toast
        const msg = document.createElement('span');
        msg.textContent = "Install Clnr on your device?";
        toast.appendChild(msg);
      
        // Create the "Install" button
        const btn = document.createElement('button');
        btn.textContent = "Install";
        btn.className = "btn";
        btn.style.background = '#3e5c4e';
        btn.style.color = '#fff';
        btn.style.marginLeft = '1em';
        btn.style.padding = '.55em 1.2em';
        btn.style.borderRadius = '0.7em';
        btn.style.fontSize = '1em';
        btn.style.border = 'none';
        btn.style.cursor = 'pointer';
      
        // On button click, show the install prompt
        btn.onclick = () => {
          deferredPrompt.prompt();
          deferredPrompt.userChoice.then((choiceResult) => {
            if (choiceResult.outcome === 'accepted') {
              // Remove the toast if the user accepted the install
              toast.remove();
            }
          });
        };
        toast.appendChild(btn);
      
        // Add a close button (×) to manually dismiss the toast
        const closeBtn = document.createElement('button');
        closeBtn.innerHTML = "&times;";
        closeBtn.style.background = "none";
        closeBtn.style.border = "none";
        closeBtn.style.color = "#fff";
        closeBtn.style.fontSize = "1.3em";
        closeBtn.style.marginLeft = ".7em";
        closeBtn.style.cursor = "pointer";
        closeBtn.onclick = () => toast.remove();
        toast.appendChild(closeBtn);
      
        // Append the toast to the document body
        document.body.appendChild(toast);
      
        // Close the toast if the user clicks outside of it
        setTimeout(() => {
          document.addEventListener('click', function autoClose(e) {
            if (!toast.contains(e.target)) {
              toast.remove();
              document.removeEventListener('click', autoClose);
            }
          });
        }, 100);
      
        // Automatically remove the toast after 15 seconds
        setTimeout(() => {
          if (document.body.contains(toast)) toast.remove();
        }, 15000);
      });
    </script>
  </body>
</html>
